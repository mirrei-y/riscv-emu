# 圧縮命令のデコードを実装する

## RISC-V 圧縮命令とは

RISC-V の圧縮命令 (16bit 命令) は、命令の下位 2 ビットが `11` でない場合に該当する。
確かに今まで `00`, `01`, `10` のパターンは使っていなかった。

ところで RISC-V というのはその名の通り RISC のアーキテクチャなので、命令の数が少ない。

しかし命令の数が少ないということは、同じ処理をするのに複数の命令を組み合わせて実現しなければならない、つまり同じ処理をするのに必要な命令数が多くなる。
そこで、よく使う命令を短い命令 (16bit) に圧縮することで、プログラム全体の命令数を減らし、メモリ使用量を削減することができる……といった感じになるようだ。

### 感想

ISA によってメモリ使用量が変わるとなると (考えてみれば、それはそう)、ISA を定義する側も大変だなあ……。
それと、圧縮すると命令長が 16bit, 32bit と混在することになるが、それは[固定命令語長であるという RISC の定義](https://ja.wikipedia.org/wiki/RISC#%E7%89%B9%E5%BE%B4)に反しそうな気もするが……。

ってか decode って u64 受け付けるけど u32 じゃね？
後で修正したい……。

それと気づいたこととして、オペコードを自分で追加したりできるのか。確かに当たり前だけど面白そうだな。

## 微調整

今までは fetch の際に 4 バイト固定で PC を進めていた。
今回の変更で fetch はそのまま 64bit 単位で行うものの、デコード前に上記の判定を行い、デコードの関数を以下のように分岐させる:

- decode が u64 を読む
- decode_compressed が u16 を読む
- execute 側が PC を進める

そういえばもうテスト2週間前を切っていることにここでようやく気付く。
私の勉強時間も効率よく圧縮できないものか？
