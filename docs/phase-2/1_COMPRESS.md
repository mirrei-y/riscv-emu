# 圧縮命令のデコードを実装する

## RISC-V 圧縮命令とは

RISC-V の圧縮命令 (16bit 命令) は、命令の下位 2 ビットが `11` でない場合に該当する。
確かに今まで `00`, `01`, `10` のパターンは使っていなかった。

ところで RISC-V というのはその名の通り RISC のアーキテクチャなので、命令の数が少ない。

しかし命令の数が少ないということは、同じ処理をするのに複数の命令を組み合わせて実現しなければならない、つまり同じ処理をするのに必要な命令数が多くなる。
そこで、よく使う命令を短い命令 (16bit) に圧縮することで、プログラム全体の命令数を減らし、メモリ使用量を削減することができる……といった感じになるようだ。

### 感想

ISA によってメモリ使用量が変わるとなると (考えてみれば、それはそう)、ISA を定義する側も大変だなあ……。
それと、圧縮すると命令長が 16bit, 32bit と混在することになるが、それは[固定命令語長であるという RISC の定義](https://ja.wikipedia.org/wiki/RISC#%E7%89%B9%E5%BE%B4)に反しそうな気もするが……。

ってか decode って u64 受け付けるけど u32 じゃね？
後で修正したい……。

それと気づいたこととして、オペコードを自分で追加したりできるのか。確かに当たり前だけど面白そうだな。

## decode の分岐

今までは fetch の際に 4 バイト固定で PC を進めていた。
今回の変更で fetch はそのまま 64bit 単位で行うものの、デコード前に上記の判定を行い、デコードの関数を以下のように分岐させる:

- decode が u64 を読む
- decode_compressed が u16 を読む
- execute 側が PC を進める

そういえばもうテスト2週間前を切っていることにここでようやく気付く。
私の勉強時間も効率よく圧縮できないものか？

## decode_compressed の実装

単純作業地獄が始まります。

ぱっと見、Imm のビットの取り方がありえないくらい複雑で面倒。
最近ビット演算ばっかりしてるよ！！！！！これをソフトウェア的にやると考えると、エミュレータが重いのも納得。

### RV32C と RV64C の違い

実装の最中に RV32C と RV64C で同じバイト列で表現する命令がそれぞれあることに気づいた (例えば `C.JAL` と `C.ADDIW` とか)。
じゃあ match 文で分岐させられないじゃん、と思い Gemini に聞くと、このエミュレータは RV64 で実装しているから RV64 として解釈すれば良い、とのこと。

Linux を動かすことが最終目標なので、RV32 をサポートする予定は今のところないが、RV32 を将来的にサポートするとなると、レジスタの幅やメモリ操作命令の挙動の分岐が必要になりそう。
Gemini に聞いたら「あと仮想メモリとかもですね、今のところ Sv39 (ロードマップで計画済み。3段階のページテーブル参照) や Sv48 (4段階のページテーブル参照) を使ってますが、RV32 だと Sv32 (2段階のページテーブル参照) じゃないと無理ですね」とのこと。

### cpu.rs の肥大化とテスト問題

ファイルが 900 行を超えてきた。これはまずい。
そして「これ動きそう？」ってコードを投げても、Gemini の返答がコロコロ変わるようになってきた。こりゃ不安になる。
次はちょっとさすがにテスト動かせるようにしたい。このまま進めると負債がたまる気がする。
